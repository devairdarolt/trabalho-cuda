// 0 <= x=0 < 5 ... 5 <= x=1 <= 10
int n = _device_global_array_size/_device_global_nr_thread; // n = sub_arr_size	
int a = x * n; // if x=0 -> a=0 ... if x=1 --> a=5...  if x=10 --> a = 50
int resto=_device_global_array_size%_device_global_nr_thread;
if((_device_global_array_size%_device_global_nr_thread!=0)&&(x==_device_global_nr_thread-1)){
	n+=resto;
}
//int a = x * n; // if x=0 -> a=0 ... if x=1 --> a=5...  if x=10 --> a = 50
int *sub_arr = (int *)malloc(n * sizeof(int));// Cria na memória um espaço para um sub_array

//sub_array recebe a referencia da posição inicial do vetor global
//sub_arr = &_device_global_array[a];
int j=0;
for(int i=a;i<a+n;i++,j++){
	sub_arr[j]=_device_global_array[i];
}
//memcpy(&sub_arr[0],&_device_global_array[a],sizeof(int)*n);

int m = device_radix_get_max_val(sub_arr, n); 
//iteração para cada dígito, no caso de um int muito grande esse for vai ocorrer 2^32 -> (10 casas) 
for (int exp = 1; m / exp > 0; exp *= 10) {
	device_radix_sort_subarray(&sub_arr[0], n, exp); 
}	

j=0;
for(int i=a;i<a+n;i++,j++){
	_device_global_array[i]=sub_arr[j];
}

	return 0;
}


///////////////////////////////////////////////////////////////////
//MODO 1 - realiza o merge usando os cuda cores
	/*************  UTILIZA MUITA MEMÓRIA DA PLACA DE VÍDEO
	while(nthreads>1){
		
		nthreads = ceil((double)nthreads/(double)2);		
		KERNEL_merge<<<1,nthreads>>>(nthreads);	
		cudaDeviceSynchronize();
		//printf("\n\n\nPos KERNEL_merge\n");
		//KERNEL_print_array<<<1,1>>>();
		//cudaDeviceSynchronize();
	}		
	/**/